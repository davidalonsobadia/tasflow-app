import 'dart:convert';
import 'package:dio/dio.dart';
import 'package:taskflow_app/core/network/api_client_dio.dart';
import 'package:taskflow_app/core/network/endpoints.dart';
import 'package:taskflow_app/core/network/exceptions.dart';
import 'package:taskflow_app/features/images/data/models/image_model.dart';
import 'package:taskflow_app/features/images/data/models/attachment_metadata_model.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_translate/flutter_translate.dart';

abstract class ImageRemoteDataSource {
  Future<List<ImageModel>> getImages(String taskId);
  Future<ImageModel> addImage(ImageModel image);
  Future<void> deleteImage(String systemId);
  Future<int> getImagesCount(String taskId);
}

class ImageRemoteDataSourceImpl implements ImageRemoteDataSource {
  final DioApiClient apiClient;

  ImageRemoteDataSourceImpl(this.apiClient);

  @override
  Future<List<ImageModel>> getImages(String taskId) async {
    try {
      // Step 1: Get attachment metadata
      final attachmentMetadata = await _getAttachmentMetadata(taskId);

      // Step 2: Download binary data for each attachment
      final images = <ImageModel>[];
      for (final metadata in attachmentMetadata) {
        final imageFormats = [
          'jpg',
          'jpeg',
          'bmp',
          'png',
          'tiff',
          'tif',
          'gif',
        ];
        Uint8List imageData = Uint8List(
          0,
        ); // Default to empty (will show placeholder)

        // Only attempt to download if documentReferenceID is valid
        if (_isValidDocumentReferenceID(metadata.documentReferenceID) &&
            imageFormats.contains(metadata.fileExtension.toLowerCase())) {
          try {
            imageData = await _downloadImageBinary(
              metadata.documentReferenceID!,
            );
          } catch (e) {
            // Log the error but continue with other images
            if (kDebugMode) {
              debugPrint(
                'Failed to download image for ${metadata.fileName}: $e',
              );
            }
            // imageData remains Uint8List(0), which will show the default placeholder
          }
        }

        final imageModel = ImageModel(
          taskId: metadata.taskId,
          fileName: metadata.fileName,
          fileExtension: metadata.fileExtension,
          imageData: imageData,
          systemId: metadata.systemId,
          documentReferenceID: metadata.documentReferenceID,
        );
        images.add(imageModel);
      }

      return images;
    } catch (e) {
      if (e is DioException) {
        throw ServerException(translate('failedToLoadImages'), e.response);
      }
      throw ValidationException(translate('invalidImageDataFormat'), e);
    }
  }

  @override
  Future<ImageModel> addImage(ImageModel image) async {
    try {
      // Step 1: Create attachment metadata
      final metadataResponse = await apiClient.post(
        Endpoints.attachmentsV2Endpoint,
        data:
            AttachmentMetadataModel(
              systemId: '', // Will be generated by server
              taskId: image.taskId,
              fileName: image.fileName,
              fileExtension: image.fileExtension,
            ).toJson(),
      );

      if (metadataResponse.statusCode != 200 &&
          metadataResponse.statusCode != 201) {
        throw ServerException(translate('failedToAddImage'), metadataResponse);
      }

      final metadata = AttachmentMetadataModel.fromJson(metadataResponse.data);

      // Step 2: Upload binary data
      final mimeType = _mimeTypeFromExtension(image.fileExtension);
      final uploadResponse = await apiClient.putBinary(
        Endpoints.attachmentsV2FileContentEndpoint(metadata.systemId),
        image.imageData,
        contentType: mimeType,
      );

      if (uploadResponse.statusCode != 204) {
        throw ServerException(translate('failedToAddImage'), uploadResponse);
      }

      return ImageModel(
        taskId: metadata.taskId,
        fileName: metadata.fileName,
        fileExtension: metadata.fileExtension,
        imageData: image.imageData,
        systemId: metadata.systemId,
        documentReferenceID: metadata.documentReferenceID,
      );
    } catch (e) {
      if (e is DioException) {
        throw ServerException(translate('failedToAddImage'), e.response);
      }
      throw ValidationException(translate('invalidImageDataFormat'), e);
    }
  }

  @override
  Future<void> deleteImage(String systemId) async {
    try {
      String deleteParam = '($systemId)';
      final response = await apiClient.delete(
        Endpoints.attachmentsV2Endpoint + deleteParam,
      );
      if (response.statusCode != 200 && response.statusCode != 204) {
        throw ServerException(translate('failedToDeleteImage'), response);
      }
    } catch (e) {
      if (e is DioException) {
        throw ServerException(translate('failedToDeleteImage'), e.response);
      }
      throw ValidationException(translate('invalidImageDataFormat'), e);
    }
  }

  @override
  Future<int> getImagesCount(String taskId) async {
    final queryParams = Map<String, dynamic>.from({
      "\$count": "true",
      "\$top": 0,
      "\$filter": "no eq '$taskId'",
    });
    try {
      final response = await apiClient.get(
        Endpoints.attachmentsV2Endpoint,
        params: queryParams,
      );
      if (response.statusCode != 200) {
        throw ServerException("Failed to get images count", response);
      }
      return response.data['@odata.count'];
    } catch (e) {
      if (e is DioException) {
        throw ServerException(translate('failedToLoadImages'), e.response);
      }
      throw ValidationException(translate('invalidImageDataFormat'), e);
    }
  }

  /// Step 1: Get attachment metadata for a task
  Future<List<AttachmentMetadataModel>> _getAttachmentMetadata(
    String taskId,
  ) async {
    final queryParams = {
      "\$filter": "no eq '$taskId'",
      "\$select": "systemId,documentReferenceID,no,fileName,fileExtension",
      "\$count": "true",
    };

    final response = await apiClient.get(
      Endpoints.attachmentsV2Endpoint,
      params: queryParams,
    );
    if (response.statusCode != 200) {
      throw ServerException(translate('failedToLoadImages'), response);
    }

    final List<dynamic> data = response.data['value'] ?? [];
    return data.map((json) => AttachmentMetadataModel.fromJson(json)).toList();
  }

  /// Step 2: Download binary image data
  Future<Uint8List> _downloadImageBinary(String documentReferenceID) async {
    final response = await apiClient.getBinary(
      Endpoints.tenantMediasFileContentEndpoint(documentReferenceID),
    );

    if (response.statusCode != 200) {
      throw ServerException(translate('failedToLoadImages'), response);
    }

    final data = response.data!;
    Uint8List bytes;

    // Detect if the response is a JSON array of numbers
    if (data.isNotEmpty && data.first == 91) {
      // ASCII '['
      final jsonString = String.fromCharCodes(data);
      final List<dynamic> numberList = jsonDecode(jsonString);
      bytes = Uint8List.fromList(numberList.cast<int>());
    } else {
      // Already raw bytes
      bytes = Uint8List.fromList(data);
    }

    return bytes;
  }

  /// Check if documentReferenceID is valid (not null and not all zeros)
  bool _isValidDocumentReferenceID(String? documentReferenceID) {
    if (documentReferenceID == null || documentReferenceID.isEmpty) {
      return false;
    }
    // Check if it's the all-zeros GUID
    if (documentReferenceID == '00000000-0000-0000-0000-000000000000') {
      return false;
    }
    return true;
  }

  String _mimeTypeFromExtension(String extension) {
    final ext = extension.toLowerCase().replaceAll('.', '');
    switch (ext) {
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'gif':
        return 'image/gif';
      case 'bmp':
        return 'image/bmp';
      case 'tif':
      case 'tiff':
        return 'image/tiff';
      default:
        return 'application/octet-stream';
    }
  }
}
